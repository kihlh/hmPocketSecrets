
/**所有防抖数据都会在这里存放 */
const ConstShakeList: Set<ShakeKey> = new Set;
const handleShakeEventList: { key: ShakeKey, type: "add" | "remove" | "has", CallBack: (this: typeof ConstShakeList, type: "add" | "remove" | "has", Time: number | undefined,) => void }[] = [];

/**
 * 删除键值 
 * @param Key 键值
 * @param Timeout 延迟执行时间 没有则直接删除
 * @returns 
 */
function RemoveShakeKey(Key: ShakeKey, Timeout?: number, CallBack?: () => void) {
    if (Timeout) {
        setTimeout(() => {
            ConstShakeList.delete(Key);
            if (CallBack) CallBack();
            for (const handleShake of handleShakeEventList) if (handleShake.key == Key) handleShake.CallBack.apply(ConstShakeList, ["remove", Timeout])
        }, Timeout)
        return true
    }
    ConstShakeList.delete(Key);
    for (const handleShake of handleShakeEventList) if (handleShake.key == Key) handleShake.CallBack.apply(ConstShakeList, ["remove", Timeout])
    return true
}
/**
 * 添加防抖key
 * @param Key 键值
 * @param Timeout 超时时间 没有则永久
 */
function SetShakeKey(Key: ShakeKey, Timeout?: number, CallBack?: () => void) {
    ConstShakeList.add(Key);
    if (Timeout) RemoveShakeKey(Key, Timeout, CallBack);
    for (const handleShake of handleShakeEventList) if (handleShake.key == Key) handleShake.CallBack.apply(ConstShakeList, ["add", Timeout])
}
/**
 * 判断是否有这个Key
 */
const HasShakeKey = (key: ShakeKey) => {
    for (const handleShake of handleShakeEventList) if (handleShake.key == key) handleShake.CallBack.apply(ConstShakeList, ["has", undefined])
    return ConstShakeList.has(key)
};
/**
 * 已有的防抖则返回 true  没有则添加
 * @param Key 键值
 * @param Timeout 超时时间
 */
function HasIfNotAdd(Key: ShakeKey, Timeout?: number, CallBack?: () => void): boolean {
    if (HasShakeKey(Key)) return true;
    SetShakeKey(Key, Timeout, CallBack)
    return false
}

/**
* 随机数值
* @param {*} Min 最小
* @param {*} Max 最大
*/
function GetRandomNum(Min: number, Max: number): number {
    var Range = Max - Min;
    var Rand = Math.random();
    return (Min + Math.round(Rand * Range));
}
/**
 * 已有的防抖则返回 true  没有则添加 并随机延时
 * @param Key 键值
 * @param MinTimeout 最小超时时间
 * @param MaxTimeout 最大超时时间
 */
function Random(Key: ShakeKey, MinTimeout?: number | [number, number], MaxTimeout?: number) {
    if (Array.isArray(MinTimeout)) {
        MaxTimeout = MinTimeout[1];
        MinTimeout = MinTimeout[0];
    }
    let Timeout = GetRandomNum(MinTimeout || 500, MaxTimeout || 5000);
    if (HasShakeKey(Key)) return true;
    SetShakeKey(Key, Timeout)
    return false
}
/**
 * 监听事件冒泡
 * @param Key 
 * @param type 
 * @param CallBack 
 */
function on(Key: ShakeKey, type: typeof handleShakeEventList[0]["type"], CallBack: typeof handleShakeEventList[0]["CallBack"]) {
    if (Key && type && !!CallBack) {
        handleShakeEventList.push({
            key: Key,
            type: type,
            CallBack: CallBack
        })
    }

}
/**
 * 没有该键值的时候添加 到时间后返回异步成功 存在时返回异步失败
 * @param key 键值
 * @param ms 延迟
 * @returns 
 */
function nextTick(key: ShakeKey, ms: number): Promise<void> {
    return new Promise((resolve, reject) => {
        if (HasShakeKey(key)) return reject();
        HasIfNotAdd(key, ms, () => resolve());
    });
}

/**
 * 所有键的数量
 * @returns 
 */
const GetShakeKeySize = () => { return ConstShakeList.size };
/**
 * 已有的防抖则返回 true  没有则添加
 * @param Key 键值
 * @param Timeout 超时时间
 */
let isset = HasIfNotAdd;
/**判断是否有这个Key */
let get = HasShakeKey;
/**
 * 添加防抖key
 * @param Key 键值
 * @param Timeout 超时时间 没有则永久
 */
let set = SetShakeKey;

/**
 * 固定该键值
 * @param Key 键值 
 * @returns 
 */
let Const = (Key: ShakeKey) => SetShakeKey(Key);
/**
 * 删除一个键值
 * @param Key 键值
 * @param Timeout 延迟执行时间 没有则直接删除
 * @param CallBack 删除成功后发生的回调
 * @returns 
 */
let remove = RemoveShakeKey;
/**
 * 删除一个键值
 * @param Key 键值
 * @param Timeout 延迟执行时间 没有则直接删除
 * @param CallBack 删除成功后发生的回调
 * @returns 
 */
let del = RemoveShakeKey;
/**判断是否有这个Key */
let has = HasShakeKey;
/**所有键值数量 */
let GetSize = GetShakeKeySize;
/** 所有防抖数据都会在这里存放*/
let ShakeList = ConstShakeList;
/**
 * 异步阻塞
 * @param ms 
 * @returns 
 */
function Sleep(ms: number): Promise<void> {
    let FormatMs = isNaN(Number(ms)) ? 150 : Number(ms);
    return new Promise((resolve) => setTimeout(resolve, Number(FormatMs)));
}

/**
 * 当使用的键值存在时将返回一个 false 并拒绝回调
 * 如果没有回调函数将返回一个异步
 * 如果有回调将会返回 true
 * @param key 键
 * @param IgnoreTime 忽略时间
 * @param awitTitme 再次延迟|回调
 * @param CallBack 回调
 * @example ```
 * 
 * shake.wait("wait-key",2500,50)?.then(()=>console.log("延迟执行 2500+50 (2550ms)"));
 * // 在 2500+50(2550ms)内的所有回调都将被忽略 不执行
 * shake.wait("wait-key",2500,function(){console.log('上次还没完成 被忽略 不执行')},50);
 * // 键值存在 无法产生一个异步对象 而是产生一个false 所以这个执行会报错 
 * shake.wait("wait-key",2500).then(()=>{});
 * 
 * // 延迟2555ms 后执行(键因超时移除了)
 * await shake.Sleep(2500+50+5);
 * shake.wait("wait-key",500).then(()=>{console.log("上次延迟结束了，可以继续添加延迟执行")});
 * ```
*/
function wait(key: string | string[], IgnoreTime: number, awitTitme: number, CallBack: () => void): boolean;
function wait(key: string | string[], IgnoreTime: number, awitTitme: () => void): boolean;
function wait(key: string | string[], IgnoreTime: number, awitTitme?: number): false | Promise<void>;
function wait(key: string | string[], IgnoreTime: number, awitTitme?: unknown, CallBack?: () => void): unknown {
    let _CallBack = typeof awitTitme == "function" ? awitTitme : typeof CallBack == "function" ? CallBack : null;
    if (Array.isArray(key)) key = key.join('::');
    if (ConstShakeList.has(key)) {
        return false;
    }
    ConstShakeList.add(key);
    let _Promise = new Promise(async function (resolve, reject) {
        await Sleep(IgnoreTime);
        if (typeof awitTitme == "number") await Sleep(awitTitme);
        ConstShakeList.delete(typeof key == "string" ? key : key.join("::"));
        _CallBack && _CallBack();
        resolve(undefined);
    });

    return _CallBack ? true : _Promise;
}
/**
 * 随机的文本id
 * @returns 
 */
function ID() { return (Date.now().toString(36) + Math.random().toString(36).slice(2, 7)).toUpperCase() }

type Shake = {
    /**
     * 已有的防抖则返回 true  没有则添加
     * @param Key 键值
     * @param Timeout 超时时间
     */
    isset: (Key: ShakeKey, Timeout?: number | undefined, CallBack?: (() => void) | undefined) => boolean
    /**
     * 一个随机的 不任意重复的文本
     */
    ID(): string
    /**
     * 判断是否有这个Key
     */
    get: (key: ShakeKey) => boolean
    /**
     * 定一个需要手动删除的防抖key
     * @param Key 
     * @returns 
     */
    Const: (Key: ShakeKey) => void
    /**
     * 删除一个键值
     * @param Key 键值
     * @param Timeout 延迟执行时间 没有则直接删除
     * @param CallBack 删除成功后发生的回调
     * @returns 
     */
    remove: (Key: ShakeKey, Timeout?: number | undefined, CallBack?: (() => void) | undefined) => boolean
    /**
     * 添加防抖key
     * @param Key 键值
     * @param Timeout 超时时间 没有则永久
     */
    set: (Key: ShakeKey, Timeout?: number | undefined, CallBack?: (() => void) | undefined) => void
    /**
     * 判断是否有这个Key
     */
    has: (key: ShakeKey) => boolean
    /**
     * 获取当前的键值数量
     * @returns 
     */
    GetSize: () => number
    /**
     * 一个异步延迟执行的方法
     * @param ms 毫秒
     */
    Sleep(ms: number): Promise<void>
    /**
     * 所有防抖参数的列表
     */
    ShakeList: Set<ShakeKey>
    /**
     * 监听防抖参数的变化
     * @param Key 键
     * @param type 更新类型
     * @param CallBack 回调 
     */
    on(Key: ShakeKey, type: (typeof handleShakeEventList)[0]["type"], CallBack: (typeof handleShakeEventList)[0]["CallBack"]): void
    /**
     * 删除一个键值
     * @param Key 键值
     * @param Timeout 延迟执行时间 没有则直接删除
     * @param CallBack 删除成功后发生的回调
     * @returns 
     */
    del: (Key: ShakeKey, Timeout?: number | undefined, CallBack?: (() => void) | undefined) => boolean
    /**
     * 没有该键值的时候添加 到时间后返回异步成功 存在时返回异步失败
     * @param key 键值
     * @param ms 延迟
     * @returns 
     */
    nextTick: (key: ShakeKey, ms: number) => Promise<void>
    /**
     * 一个随机延迟的防抖值
     * @param Key 键
     * @param MinTimeout 最小的延迟时间 
     * @param MaxTimeout 最大的延迟时间
     * @returns 
     */
    Random: (Key: ShakeKey, MinTimeout?: number | [number, number], MaxTimeout?: number) => boolean
    /**
     * 当使用的键值存在时将返回一个 false 并拒绝回调
     * 如果没有回调函数将返回一个异步
     * 如果有回调将会返回 true
     * @param key 键
     * @param IgnoreTime 忽略时间
     * @param awitTitme 再次延迟|回调
     * @param CallBack 回调
     * @example ```
     * 
     * shake.wait("wait-key",2500,50)?.then(()=>console.log("延迟执行 2500+50 (2550ms)"));
     * // 在 2500+50(2550ms)内的所有回调都将被忽略 不执行
     * shake.wait("wait-key",2500,function(){console.log('上次还没完成 被忽略 不执行')},50);
     * // 键值存在 无法产生一个异步对象 而是产生一个false 所以这个执行会报错 
     * shake.wait("wait-key",2500).then(()=>{});
     * 
     * // 延迟2555ms 后执行(键因超时移除了)
     * await shake.Sleep(2500+50+5);
     * shake.wait("wait-key",500).then(()=>{console.log("上次延迟结束了，可以继续添加延迟执行")});
     * ```
    */
    wait: typeof wait;
}

export let shake: Shake = {

    wait, isset, get, set, Const, remove, del, has, GetSize, ShakeList, nextTick, Random, on, Sleep, ID
}
type ShakeKey = string | number
export {
    wait, isset, get, set, Const, remove, del, has, GetSize, ShakeList, nextTick, Random, on, Sleep, ID
}

export default shake;
